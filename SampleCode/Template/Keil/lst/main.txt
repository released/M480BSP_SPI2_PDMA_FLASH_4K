; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Custom_Init||, CODE, READONLY, ALIGN=2

                  Custom_Init PROC
;;;582    
;;;583    void Custom_Init(void)
000000  b510              PUSH     {r4,lr}
;;;584    {	
;;;585    	//EVM LED
;;;586    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c0c              LDR      r4,|L1.52|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;587    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;588    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  2201              MOVS     r2,#1
00001a  2104              MOVS     r1,#4
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_SetMode
;;;589    
;;;590    	//EVM button
;;;591    	GPIO_SetMode(PG,BIT15,GPIO_MODE_INPUT);	
000022  13e1              ASRS     r1,r4,#15
000024  4803              LDR      r0,|L1.52|
000026  2200              MOVS     r2,#0
000028  e8bd4010          POP      {r4,lr}
00002c  3840              SUBS     r0,r0,#0x40
00002e  f7ffbffe          B.W      GPIO_SetMode
;;;592    	
;;;593    }
;;;594    
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;595    
;;;596    void SYS_Init(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;597    {
000004  2059              MOVS     r0,#0x59
000006  0784              LSLS     r4,r0,#30
000008  2116              MOVS     r1,#0x16
00000a  2288              MOVS     r2,#0x88
                  |L3.12|
00000c  f8c40100          STR      r0,[r4,#0x100]
000010  f8c41100          STR      r1,[r4,#0x100]
000014  f8c42100          STR      r2,[r4,#0x100]
000018  f8d43100          LDR      r3,[r4,#0x100]
00001c  2b00              CMP      r3,#0
00001e  d0f5              BEQ      |L3.12|
;;;598        /*---------------------------------------------------------------------------------------------------------*/
;;;599        /* Init System Clock                                                                                       */
;;;600        /*---------------------------------------------------------------------------------------------------------*/
;;;601        /* Unlock protected registers */
;;;602        SYS_UnlockReg();
;;;603    
;;;604        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;605        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
000020  f04f2540          MOV      r5,#0x40004000
000024  f8d50140          LDR      r0,[r5,#0x140]
000028  f02000f0          BIC      r0,r0,#0xf0
00002c  f8c50140          STR      r0,[r5,#0x140]
;;;606    
;;;607        /* Enable External XTAL (4~24 MHz) */
;;;608        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk|CLK_PWRCTL_HIRCEN_Msk|CLK_PWRCTL_LIRCEN_Msk);
000030  200d              MOVS     r0,#0xd
000032  f7fffffe          BL       CLK_EnableXtalRC
;;;609    
;;;610        /* Waiting for 12MHz clock ready */
;;;611        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk|CLK_STATUS_HIRCSTB_Msk|CLK_STATUS_LIRCSTB_Msk);
000036  2019              MOVS     r0,#0x19
000038  f7fffffe          BL       CLK_WaitClockReady
;;;612    
;;;613        /* Set core clock as PLL_CLOCK from PLL */
;;;614        CLK_SetCoreClock(FREQ_192MHZ);
00003c  4848              LDR      r0,|L3.352|
00003e  f7fffffe          BL       CLK_SetCoreClock
;;;615        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;616        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000042  2011              MOVS     r0,#0x11
000044  f8c40234          STR      r0,[r4,#0x234]
;;;617    
;;;618        /* Enable UART clock */
;;;619        CLK_EnableModuleClock(UART0_MODULE);
000048  4e46              LDR      r6,|L3.356|
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       CLK_EnableModuleClock
;;;620        /* Select UART clock source from HXT */
;;;621        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
000050  2200              MOVS     r2,#0
000052  f04f7140          MOV      r1,#0x3000000
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       CLK_SetModuleClock
;;;622    
;;;623        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;624        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
00005c  6be0              LDR      r0,[r4,#0x3c]
00005e  f420007f          BIC      r0,r0,#0xff0000
000062  63e0              STR      r0,[r4,#0x3c]
;;;625        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000064  6be0              LDR      r0,[r4,#0x3c]
000066  f44000cc          ORR      r0,r0,#0x660000
00006a  63e0              STR      r0,[r4,#0x3c]
;;;626    
;;;627    
;;;628        CLK_EnableModuleClock(UART5_MODULE);
00006c  4e3e              LDR      r6,|L3.360|
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       CLK_EnableModuleClock
;;;629        /* Select UART clock source from HXT */
;;;630        CLK_SetModuleClock(UART5_MODULE, CLK_CLKSEL3_UART5SEL_HIRC, CLK_CLKDIV4_UART5(1));
000074  2200              MOVS     r2,#0
000076  f04f4140          MOV      r1,#0xc0000000
00007a  4630              MOV      r0,r6
00007c  f7fffffe          BL       CLK_SetModuleClock
;;;631    
;;;632        CLK_SetModuleClock(SPI0_MODULE, CLK_CLKSEL2_SPI0SEL_HIRC, MODULE_NoMsk);
000080  4e3a              LDR      r6,|L3.364|
000082  2200              MOVS     r2,#0
000084  2130              MOVS     r1,#0x30
000086  4630              MOV      r0,r6
000088  f7fffffe          BL       CLK_SetModuleClock
;;;633        CLK_EnableModuleClock(SPI0_MODULE);
00008c  4630              MOV      r0,r6
00008e  f7fffffe          BL       CLK_EnableModuleClock
;;;634    
;;;635        CLK_SetModuleClock(SPI2_MODULE, CLK_CLKSEL2_SPI2SEL_HIRC, MODULE_NoMsk);
000092  4e37              LDR      r6,|L3.368|
000094  2200              MOVS     r2,#0
000096  f44f6140          MOV      r1,#0xc00
00009a  4630              MOV      r0,r6
00009c  f7fffffe          BL       CLK_SetModuleClock
;;;636        CLK_EnableModuleClock(SPI2_MODULE);
0000a0  4630              MOV      r0,r6
0000a2  f7fffffe          BL       CLK_EnableModuleClock
;;;637    
;;;638        CLK_EnableModuleClock(PDMA_MODULE);
0000a6  2001              MOVS     r0,#1
0000a8  f7fffffe          BL       CLK_EnableModuleClock
;;;639    
;;;640    	CLK_EnableModuleClock(TMR0_MODULE);
0000ac  4e31              LDR      r6,|L3.372|
0000ae  4630              MOV      r0,r6
0000b0  f7fffffe          BL       CLK_EnableModuleClock
;;;641    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HIRC, 0);
0000b4  f44f67e0          MOV      r7,#0x700
0000b8  2200              MOVS     r2,#0
0000ba  4639              MOV      r1,r7
0000bc  4630              MOV      r0,r6
0000be  f7fffffe          BL       CLK_SetModuleClock
;;;642    	
;;;643        CLK_EnableModuleClock(TMR1_MODULE);
0000c2  4e2d              LDR      r6,|L3.376|
0000c4  4630              MOV      r0,r6
0000c6  f7fffffe          BL       CLK_EnableModuleClock
;;;644        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
0000ca  2200              MOVS     r2,#0
0000cc  0139              LSLS     r1,r7,#4
0000ce  4630              MOV      r0,r6
0000d0  f7fffffe          BL       CLK_SetModuleClock
;;;645    
;;;646        CLK_EnableModuleClock(QEI0_MODULE);
0000d4  4829              LDR      r0,|L3.380|
0000d6  f7fffffe          BL       CLK_EnableModuleClock
;;;647    
;;;648        CLK_EnableModuleClock(WDT_MODULE);
0000da  f04f46ac          MOV      r6,#0x56000000
0000de  4630              MOV      r0,r6
0000e0  f7fffffe          BL       CLK_EnableModuleClock
;;;649        CLK_SetModuleClock(WDT_MODULE, CLK_CLKSEL1_WDTSEL_LIRC, 0);
0000e4  2200              MOVS     r2,#0
0000e6  2103              MOVS     r1,#3
0000e8  4630              MOV      r0,r6
0000ea  f7fffffe          BL       CLK_SetModuleClock
;;;650    	
;;;651    	
;;;652        /* Update System Core Clock */
;;;653        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;654        SystemCoreClockUpdate();
0000ee  f7fffffe          BL       SystemCoreClockUpdate
;;;655    
;;;656        SYS->GPA_MFPL &= ~(SYS_GPA_MFPL_PA5MFP_Msk  );
0000f2  6b20              LDR      r0,[r4,#0x30]
0000f4  f4200070          BIC      r0,r0,#0xf00000
0000f8  6320              STR      r0,[r4,#0x30]
;;;657        SYS->GPA_MFPL |= (SYS_GPA_MFPL_PA5MFP_UART5_TXD );
0000fa  6b20              LDR      r0,[r4,#0x30]
0000fc  f4400000          ORR      r0,r0,#0x800000
000100  6320              STR      r0,[r4,#0x30]
;;;658    
;;;659        SYS->GPA_MFPL &= ~(SYS_GPA_MFPL_PA4MFP_Msk | SYS_GPA_MFPL_PA3MFP_Msk );
000102  6b20              LDR      r0,[r4,#0x30]
000104  f420207f          BIC      r0,r0,#0xff000
000108  6320              STR      r0,[r4,#0x30]
;;;660        SYS->GPA_MFPL |= (SYS_GPA_MFPL_PA4MFP_QEI0_A | SYS_GPA_MFPL_PA3MFP_QEI0_B );
00010a  6b20              LDR      r0,[r4,#0x30]
00010c  f440206e          ORR      r0,r0,#0xee000
000110  6320              STR      r0,[r4,#0x30]
;;;661    
;;;662    	/*
;;;663    		SPI0 LED driver x 5
;;;664    
;;;665    		SPI0_LED_NSS0 : PA.6
;;;666    		SPI0_LED_NSS1 : PA.7		
;;;667    		SPI0_LED_NSS2 : PA.11
;;;668    		
;;;669    		SPI0_LED_NSS3 : PF.1 * ICE_CLK	
;;;670    		SPI0_LED_NSS4 : PF.0 * ICE_DAT
;;;671    
;;;672    		SDB : PC.14	//SNLED27351 , Hardware power down the chip when pull to low. 
;;;673    
;;;674    		SPI0_LED_MOSI : PA.0
;;;675    		SPI0_LED_MISO : PA.1		
;;;676    		SPI0_LED_CLK : PA.2
;;;677    
;;;678    	*/
;;;679        SYS->GPA_MFPL &= ~(SYS_GPA_MFPL_PA2MFP_Msk | SYS_GPA_MFPL_PA1MFP_Msk| SYS_GPA_MFPL_PA0MFP_Msk);
000112  6b20              LDR      r0,[r4,#0x30]
000114  f36f000b          BFC      r0,#0,#12
000118  6320              STR      r0,[r4,#0x30]
;;;680        SYS->GPA_MFPL |= SYS_GPA_MFPL_PA2MFP_SPI0_CLK| SYS_GPA_MFPL_PA1MFP_SPI0_MISO| SYS_GPA_MFPL_PA0MFP_SPI0_MOSI ;
00011a  6b20              LDR      r0,[r4,#0x30]
00011c  f2404644          MOV      r6,#0x444
000120  4330              ORRS     r0,r0,r6
000122  6320              STR      r0,[r4,#0x30]
;;;681    	
;;;682        /* Enable SPI0 clock pin schmitt trigger */
;;;683        PA->SMTEN |= (GPIO_SMTEN_SMTEN2_Msk | GPIO_SMTEN_SMTEN1_Msk | GPIO_SMTEN_SMTEN0_Msk);
000124  6a68              LDR      r0,[r5,#0x24]
000126  f0400007          ORR      r0,r0,#7
00012a  6268              STR      r0,[r5,#0x24]
;;;684        /* Enable SPI0 I/O high slew rate */
;;;685    	GPIO_SetSlewCtl(PA, (BIT2 | BIT1 | BIT1), GPIO_SLEWCTL_FAST);
00012c  2202              MOVS     r2,#2
00012e  2106              MOVS     r1,#6
000130  4628              MOV      r0,r5
000132  f7fffffe          BL       GPIO_SetSlewCtl
;;;686    
;;;687    
;;;688    	/* 
;;;689    		SPI2 flash , 
;;;690    		SPI2_FLASH_CLK : PA.10
;;;691    		SPI2_FLASH_MISO : PA.9
;;;692    		SPI2_FLASH_MOSI : PA.8
;;;693    		SPI2_FLAH_NSS0 : PF.6
;;;694    	*/
;;;695        SYS->GPA_MFPH &= ~(SYS_GPA_MFPH_PA10MFP_Msk | SYS_GPA_MFPH_PA9MFP_Msk| SYS_GPA_MFPH_PA8MFP_Msk);
000136  6b60              LDR      r0,[r4,#0x34]
000138  f36f000b          BFC      r0,#0,#12
00013c  6360              STR      r0,[r4,#0x34]
;;;696        SYS->GPA_MFPH |= SYS_GPA_MFPH_PA10MFP_SPI2_CLK| SYS_GPA_MFPH_PA9MFP_SPI2_MISO| SYS_GPA_MFPH_PA8MFP_SPI2_MOSI ;
00013e  6b60              LDR      r0,[r4,#0x34]
000140  4330              ORRS     r0,r0,r6
000142  6360              STR      r0,[r4,#0x34]
;;;697    
;;;698        /* Enable SPI2 clock pin schmitt trigger */
;;;699        PA->SMTEN |= (GPIO_SMTEN_SMTEN10_Msk | GPIO_SMTEN_SMTEN9_Msk | GPIO_SMTEN_SMTEN8_Msk);
000144  6a68              LDR      r0,[r5,#0x24]
000146  f44060e0          ORR      r0,r0,#0x700
00014a  6268              STR      r0,[r5,#0x24]
;;;700        /* Enable SPI2 I/O high slew rate */
;;;701    	GPIO_SetSlewCtl(PA, (BIT10 | BIT9 | BIT8), GPIO_SLEWCTL_FAST);
00014c  2202              MOVS     r2,#2
00014e  4639              MOV      r1,r7
000150  4628              MOV      r0,r5
000152  f7fffffe          BL       GPIO_SetSlewCtl
000156  2000              MOVS     r0,#0
000158  f8c40100          STR      r0,[r4,#0x100]
;;;702    	
;;;703        /* Lock protected registers */
;;;704        SYS_LockReg();
;;;705    }
00015c  e8bd81f0          POP      {r4-r8,pc}
;;;706    
                          ENDP

                  |L3.352|
                          DCD      0x0b71b000
                  |L3.356|
                          DCD      0x57803d10
                  |L3.360|
                          DCD      0x77ec3d95
                  |L3.364|
                          DCD      0x6640000d
                  |L3.368|
                          DCD      0x66a0000f
                  |L3.372|
                          DCD      0x5e800002
                  |L3.376|
                          DCD      0x5ec00003
                  |L3.380|
                          DCD      0x80000016

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;573    
;;;574    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;575    {
;;;576        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L4.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;577        TIMER_EnableInt(TIMER1);
;;;578        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;579        TIMER_Start(TIMER1);
;;;580    }
000028  bd10              POP      {r4,pc}
;;;581    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;550    
;;;551    void TMR1_IRQHandler(void)
000000  4808              LDR      r0,|L5.36|
000002  6881              LDR      r1,[r0,#8]
000004  f3c10100          UBFX     r1,r1,#0,#1
;;;552    {
000008  2900              CMP      r1,#0
00000a  d00a              BEQ      |L5.34|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;553    	static uint16_t CNT_1000ms = 0;	
;;;554    	
;;;555    //	static uint32_t log = 0;	
;;;556    	
;;;557        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;558        {
;;;559            TIMER_ClearIntFlag(TIMER1);
;;;560    	
;;;561    		if (CNT_1000ms++ > 1000)
000010  4905              LDR      r1,|L5.40|
000012  8848              LDRH     r0,[r1,#2]  ; CNT_1000ms
000014  1c42              ADDS     r2,r0,#1
000016  804a              STRH     r2,[r1,#2]
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d901              BLS      |L5.34|
;;;562    		{		
;;;563    			CNT_1000ms = 0;
00001e  2000              MOVS     r0,#0
000020  8048              STRH     r0,[r1,#2]
                  |L5.34|
;;;564    			#if (_debug_log_UART_ == 1)	//debug			
;;;565    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;566    			#endif		
;;;567    		
;;;568    		}
;;;569    	
;;;570        }
;;;571    }
000022  4770              BX       lr
;;;572    
                          ENDP

                  |L5.36|
                          DCD      0x40050100
                  |L5.40|
                          DCD      ||.data||

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;507    
;;;508    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;509    {
;;;510        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L6.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L6.18|
00000c  e004              B        |L6.24|
                  |L6.14|
;;;511        {
;;;512            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;513            {
;;;514    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L6.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;512
000014  0449              LSLS     r1,r1,#17             ;512
000016  d5fa              BPL      |L6.14|
                  |L6.24|
;;;515            }
;;;516        }
;;;517    
;;;518        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L6.46|
;;;519        {
;;;520            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L6.46|
;;;521        }
;;;522    }
00002e  bd10              POP      {r4,pc}
;;;523    
                          ENDP

                  |L6.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;523    
;;;524    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;525    {
;;;526        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L7.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;527    
;;;528        /* Configure UART0 and set UART0 baud rate */
;;;529        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L7.128|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;530    
;;;531    	/* Set UART receive time-out */
;;;532    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;533    
;;;534    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;535    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;536    
;;;537    	/* Enable UART Interrupt - */
;;;538    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;539    	
;;;540    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;541    
;;;542    	#if (_debug_log_UART_ == 1)	//debug
;;;543    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a010              ADR      r0,|L7.132|
000044  f7fffffe          BL       __2printf
;;;544    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000048  f7fffffe          BL       CLK_GetHXTFreq
00004c  4601              MOV      r1,r0
00004e  a014              ADR      r0,|L7.160|
000050  f7fffffe          BL       __2printf
;;;545    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000054  f7fffffe          BL       CLK_GetLXTFreq
000058  4601              MOV      r1,r0
00005a  a017              ADR      r0,|L7.184|
00005c  f7fffffe          BL       __2printf
;;;546    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000060  f7fffffe          BL       CLK_GetPCLK0Freq
000064  4601              MOV      r1,r0
000066  a01a              ADR      r0,|L7.208|
000068  f7fffffe          BL       __2printf
;;;547    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
00006c  f7fffffe          BL       CLK_GetPCLK1Freq
000070  4601              MOV      r1,r0
000072  e8bd4010          POP      {r4,lr}
000076  a01d              ADR      r0,|L7.236|
000078  f7ffbffe          B.W      __2printf
;;;548    	#endif
;;;549    }
;;;550    
                          ENDP

                  |L7.124|
                          DCD      0x04000010
                  |L7.128|
                          DCD      0x40070000
                  |L7.132|
000084  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000088  4b5f4765
00008c  74435055
000090  46726571
000094  203a2025
000098  38640d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L7.160|
0000a0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a4  47657448
0000a8  58544672
0000ac  6571203a
0000b0  20253864
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L7.184|
0000b8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000bc  4765744c
0000c0  58544672
0000c4  6571203a
0000c8  20253864
0000cc  0d0a00  
0000cf  00                DCB      0
                  |L7.208|
0000d0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d4  47657450
0000d8  434c4b30
0000dc  46726571
0000e0  203a2025
0000e4  38640d0a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L7.236|
0000ec  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f0  47657450
0000f4  434c4b31
0000f8  46726571
0000fc  203a2025
000100  38640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UARTx_Process PROC
;;;171    
;;;172    void UARTx_Process(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;173    {
;;;174    	uint8_t res = 0;
;;;175        uint16_t i = 0;
;;;176    	static uint8_t cnt = 0;
;;;177        uint16_t page_cnt = 0;
;;;178        uint16_t sector_cnt = 0;
;;;179    	
;;;180    	res = UART_READ(UART0);
000004  48ab              LDR      r0,|L8.692|
000006  2700              MOVS     r7,#0                 ;175
000008  463d              MOV      r5,r7                 ;177
00000a  6800              LDR      r0,[r0,#0]
00000c  463c              MOV      r4,r7                 ;178
00000e  b2c0              UXTB     r0,r0
;;;181    
;;;182    	if (res > 0x7F)
000010  287f              CMP      r0,#0x7f
000012  d901              BLS      |L8.24|
;;;183    	{
;;;184    		printf("invalid command\r\n");
000014  a0a8              ADR      r0,|L8.696|
000016  e149              B        |L8.684|
                  |L8.24|
;;;185    	}
;;;186    	else
;;;187    	{
;;;188    		switch(res)
;;;189    		{
;;;190    			case '?':
;;;191    				#if (_debug_log_UART_ == 1)	//debug
;;;192    				printf("\r\n==========================\r\n");
;;;193    				
;;;194    				printf("1: chip erase\r\n");
;;;195    				printf("2: fill in TX data\r\n");
;;;196    				printf("3: page counter\r\n");
;;;197    				printf("4: Page write\r\n");
;;;198    				printf("5: Page read\r\n");		
;;;199    				printf("6: self test , write , read , compare\r\n");	
;;;200    				printf("7: self test , write , read , compare  , with PDMA\r\n");
;;;201    				
;;;202    				printf("8: read ID (0x90)\r\n");	
;;;203    				
;;;204    				printf("==========================\r\n\r\n");
;;;205    				#endif
;;;206    				break;	
;;;207    
;;;208    		
;;;209    			case '1':
;;;210    				#if (_debug_log_UART_ == 1)	//debug
;;;211    				printf("perform SpiFlash_ChipErase\r\n");
;;;212    				#endif
;;;213    				
;;;214    			    /* Erase SPI flash */
;;;215    			    SpiFlash_ChipErase();
;;;216    
;;;217    			    /* Wait ready */
;;;218    			    SpiFlash_WaitReady();
;;;219    
;;;220    				#if (_debug_log_UART_ == 1)	//debug
;;;221    				printf("erase finish\r\n\r\n");
;;;222    				#endif
;;;223    				break;	
;;;224    
;;;225    			case '2':
;;;226    				#if (_debug_log_UART_ == 1)	//debug				
;;;227    				printf("increase test data start from 0x%2X\r\n" , cnt);
;;;228    				#endif
;;;229    
;;;230    				#if defined (TEST_SPI_PAGE)
;;;231    				//reset TxBuffer
;;;232    				reset_buffer(TxBuffer,SPI_FLASH_PAGE_BYTE);
;;;233    
;;;234    				//fill in data
;;;235    			    for ( i = 0; i < SPI_FLASH_PAGE_BYTE; i++)
;;;236    			    {
;;;237    			        TxBuffer[i] = 0x00 + i + cnt;
;;;238    			    }
;;;239    
;;;240    				#if (_debug_log_UART_ == 1)	//debug
;;;241    				printf("TxBuffer : \r\n");	
;;;242    				dump_buffer_hex(TxBuffer,SPI_FLASH_PAGE_BYTE);				
;;;243    				#endif	
;;;244    
;;;245    				#elif defined (TEST_SPI_SECTOR)
;;;246    				//reset TxBuffer
;;;247    				reset_buffer(Tx4KBuffer,SPI_FLASH_SECTOR_SIZE);
000018  f8dfa2b0          LDR      r10,|L8.716|
00001c  4eac              LDR      r6,|L8.720|
00001e  f44f5880          MOV      r8,#0x1000
000022  2838              CMP      r0,#0x38              ;188
000024  d071              BEQ      |L8.266|
000026  dc0e              BGT      |L8.70|
000028  49a9              LDR      r1,|L8.720|
;;;248    
;;;249    				//fill in data
;;;250    			    for ( i = 0; i < SPI_FLASH_SECTOR_SIZE; i++)
;;;251    			    {
;;;252    			        Tx4KBuffer[i] = 0x00 + i + cnt;
;;;253    			    }
;;;254    
;;;255    				#if (_debug_log_UART_ == 1)	//debug
;;;256    				printf("Tx4KBuffer : \r\n");	
;;;257    				dump_buffer_hex(Tx4KBuffer,SPI_FLASH_SECTOR_SIZE);				
;;;258    				#endif	
;;;259    
;;;260    				#endif				
;;;261    				cnt++; 
;;;262    			
;;;263    				break;
;;;264    
;;;265    			case '3':
;;;266    				#if (_debug_log_UART_ == 1)	//debug
;;;267    				printf("SPI_FLASH_page_counter current : 0x%2X\r\n\r\n" ,SPI_FLASH_page_counter++);	
;;;268    				#endif
;;;269    			
;;;270    				break;
;;;271    
;;;272    			case '4':
;;;273    				#if (_debug_log_UART_ == 1)	//debug
;;;274    				printf("programming...(%d)\r\n",SPI_FLASH_page_counter);
;;;275    				#endif
;;;276    
;;;277    				#if defined (TEST_SPI_PAGE)				
;;;278    //				SpiFlash_PageWrite(SPI_FLASH_page_counter,TxBuffer,SPI_FLASH_PAGE_BYTE,DISABLE);
;;;279    				SpiFlash_PageWrite(SPI_FLASH_page_counter,TxBuffer,SPI_FLASH_PAGE_BYTE,ENABLE);
;;;280    
;;;281    				#elif defined (TEST_SPI_SECTOR)
;;;282    //				SpiFlash_SectorWrite(SPI_FLASH_page_counter,Tx4KBuffer,SPI_FLASH_SECTOR_SIZE,DISABLE);
;;;283    				SpiFlash_SectorWrite(SPI_FLASH_page_counter,Tx4KBuffer,SPI_FLASH_SECTOR_SIZE,ENABLE);
;;;284    
;;;285    				#endif
;;;286    				
;;;287    				#if (_debug_log_UART_ == 1)	//debug
;;;288    				printf("programming finish\r\n\r\n");
;;;289    				#endif
;;;290    				
;;;291    				break;
;;;292    
;;;293    			case '5':
;;;294    				#if (_debug_log_UART_ == 1)	//debug
;;;295    				printf("read page ...(%2d)\r\n",SPI_FLASH_page_counter);
;;;296    				#endif
;;;297    
;;;298    				#if defined (TEST_SPI_PAGE)	
;;;299    				//reset RxBuffer
;;;300    			    reset_buffer(RxBuffer,SPI_FLASH_PAGE_BYTE);
;;;301    				
;;;302    //				SpiFlash_PageRead(SPI_FLASH_page_counter,RxBuffer,SPI_FLASH_PAGE_BYTE,DISABLE);
;;;303    				SpiFlash_PageRead(SPI_FLASH_page_counter,RxBuffer,SPI_FLASH_PAGE_BYTE,ENABLE);
;;;304    				
;;;305    				#if (_debug_log_UART_ == 1)	//debug				
;;;306    				dump_buffer_hex(RxBuffer,SPI_FLASH_PAGE_BYTE);
;;;307    				printf("read page finish\r\n\r\n");	
;;;308    				#endif
;;;309    
;;;310    				#elif defined (TEST_SPI_SECTOR)
;;;311    				//reset RxBuffer
;;;312    			    reset_buffer(Rx4KBuffer,SPI_FLASH_SECTOR_SIZE);
;;;313    				
;;;314    //				SpiFlash_SectorRead(SPI_FLASH_page_counter,Rx4KBuffer,SPI_FLASH_SECTOR_SIZE,DISABLE);
;;;315    				SpiFlash_SectorRead(SPI_FLASH_page_counter,Rx4KBuffer,SPI_FLASH_SECTOR_SIZE,ENABLE);
;;;316    				
;;;317    				#if (_debug_log_UART_ == 1)	//debug				
;;;318    				dump_buffer_hex(Rx4KBuffer,SPI_FLASH_SECTOR_SIZE);
;;;319    				printf("read page finish\r\n\r\n");	
;;;320    				#endif
;;;321    
;;;322    				#endif
;;;323    				
;;;324    				break;				
;;;325    
;;;326    			case '6':
;;;327    				#if (_debug_log_UART_ == 1)	//debug
;;;328    				printf("perform SpiFlash_ChipErase\r\n");
;;;329    				#endif
;;;330    				
;;;331    			    /* Erase SPI flash */
;;;332    			    SpiFlash_ChipErase();
;;;333    
;;;334    			    /* Wait ready */
;;;335    			    SpiFlash_WaitReady();
;;;336    
;;;337    				#if (_debug_log_UART_ == 1)	//debug
;;;338    				printf("erase finish\r\n\r\n");
;;;339    				#endif
;;;340    
;;;341    				for ( page_cnt = 0 ; page_cnt < TEST_NUMBER ; page_cnt++)
;;;342    				{
;;;343    					#if (_debug_log_UART_ == 1)	//debug
;;;344    					printf("\r\nSELF TEST ... (idx : %2d)\r\n" , page_cnt);
;;;345    					#endif
;;;346    
;;;347    					//reset RxBuffer
;;;348    				    reset_buffer(RxBuffer,SPI_FLASH_PAGE_BYTE);
;;;349    
;;;350    					//reset TxBuffer
;;;351    					reset_buffer(TxBuffer,SPI_FLASH_PAGE_BYTE);
00002a  4caa              LDR      r4,|L8.724|
00002c  f1a00031          SUB      r0,r0,#0x31           ;267
000030  7809              LDRB     r1,[r1,#0]            ;267
000032  f44f7980          MOV      r9,#0x100             ;348
000036  2807              CMP      r0,#7                 ;188
000038  d261              BCS      |L8.254|
00003a  e8dff000          TBB      [pc,r0]               ;188
00003e  3c45              DCB      0x3c,0x45
000040  62677288          DCB      0x62,0x67,0x72,0x88
000044  c000              DCB      0xc0,0x00
                  |L8.70|
000046  285a              CMP      r0,#0x5a              ;188
000048  d00b              BEQ      |L8.98|
00004a  dc06              BGT      |L8.90|
00004c  2839              CMP      r0,#0x39              ;188
00004e  d07b              BEQ      |L8.328|
000050  283f              CMP      r0,#0x3f              ;188
000052  d013              BEQ      |L8.124|
000054  2858              CMP      r0,#0x58              ;188
000056  d152              BNE      |L8.254|
000058  e003              B        |L8.98|
                  |L8.90|
00005a  2878              CMP      r0,#0x78              ;188
00005c  d001              BEQ      |L8.98|
00005e  287a              CMP      r0,#0x7a              ;188
000060  d14d              BNE      |L8.254|
                  |L8.98|
000062  f3bf8f4f          DSB                            ;188
000066  499c              LDR      r1,|L8.728|
000068  6808              LDR      r0,[r1,#0]            ;188
00006a  4a9c              LDR      r2,|L8.732|
00006c  f40060e0          AND      r0,r0,#0x700          ;188
000070  4310              ORRS     r0,r0,r2              ;188
000072  6008              STR      r0,[r1,#0]            ;188
000074  f3bf8f4f          DSB                            ;188
                  |L8.120|
000078  bf00              NOP                            ;188
00007a  e7fd              B        |L8.120|
                  |L8.124|
00007c  a098              ADR      r0,|L8.736|
00007e  f7fffffe          BL       __2printf
000082  a09f              ADR      r0,|L8.768|
000084  f7fffffe          BL       __2printf
000088  a0a1              ADR      r0,|L8.784|
00008a  f7fffffe          BL       __2printf
00008e  a0a6              ADR      r0,|L8.808|
000090  f7fffffe          BL       __2printf
000094  a0a9              ADR      r0,|L8.828|
000096  f7fffffe          BL       __2printf
00009a  a0ac              ADR      r0,|L8.844|
00009c  f7fffffe          BL       __2printf
0000a0  a0ae              ADR      r0,|L8.860|
0000a2  f7fffffe          BL       __2printf
0000a6  a0b7              ADR      r0,|L8.900|
0000a8  f7fffffe          BL       __2printf
0000ac  a0c3              ADR      r0,|L8.956|
0000ae  f7fffffe          BL       __2printf
0000b2  a0c7              ADR      r0,|L8.976|
0000b4  e0fa              B        |L8.684|
0000b6  a0ce              ADR      r0,|L8.1008|
0000b8  f7fffffe          BL       __2printf
0000bc  f7fffffe          BL       SpiFlash_ChipErase
0000c0  f7fffffe          BL       SpiFlash_WaitReady
0000c4  a0d2              ADR      r0,|L8.1040|
0000c6  e0f1              B        |L8.684|
0000c8  7871              LDRB     r1,[r6,#1]            ;227  ; cnt
0000ca  a0d6              ADR      r0,|L8.1060|
0000cc  f7fffffe          BL       __2printf
0000d0  4644              MOV      r4,r8                 ;247
0000d2  4641              MOV      r1,r8                 ;247
0000d4  487d              LDR      r0,|L8.716|
0000d6  f7fffffe          BL       reset_buffer
0000da  7870              LDRB     r0,[r6,#1]            ;227
0000dc  4652              MOV      r2,r10                ;247
                  |L8.222|
0000de  1839              ADDS     r1,r7,r0              ;252
0000e0  55d1              STRB     r1,[r2,r7]            ;252
0000e2  1c7f              ADDS     r7,r7,#1              ;252
0000e4  b2bf              UXTH     r7,r7                 ;250
0000e6  42a7              CMP      r7,r4                 ;250
0000e8  d3f9              BCC      |L8.222|
0000ea  a0d8              ADR      r0,|L8.1100|
0000ec  f7fffffe          BL       __2printf
0000f0  4621              MOV      r1,r4                 ;257
0000f2  4876              LDR      r0,|L8.716|
0000f4  f7fffffe          BL       dump_buffer_hex
0000f8  7870              LDRB     r0,[r6,#1]            ;261  ; cnt
0000fa  1c40              ADDS     r0,r0,#1              ;261
0000fc  7070              STRB     r0,[r6,#1]            ;261
                  |L8.254|
;;;352    
;;;353    					//fill in data
;;;354    				    for ( i = 0; i < SPI_FLASH_PAGE_BYTE; i++)
;;;355    				    {
;;;356    				        TxBuffer[i] = 0x00 + i + cnt;
;;;357    				    }
;;;358    
;;;359    //					printf("\r\nTxBuffer : \r\n");
;;;360    //					dump_buffer_hex(TxBuffer,SPI_FLASH_PAGE_BYTE);				
;;;361    					cnt++;
;;;362    					
;;;363    					SpiFlash_PageWrite(page_cnt,TxBuffer,SPI_FLASH_PAGE_BYTE,DISABLE);
;;;364    					SpiFlash_PageRead(page_cnt,RxBuffer,SPI_FLASH_PAGE_BYTE,DISABLE);
;;;365    
;;;366    //					printf("\r\nRxBuffer\r\n");
;;;367    //					dump_buffer_hex(RxBuffer,SPI_FLASH_PAGE_BYTE);		
;;;368    
;;;369    					compare_buffer(TxBuffer,RxBuffer,SPI_FLASH_PAGE_BYTE);
;;;370    				}
;;;371    
;;;372    				#if (_debug_log_UART_ == 1)	//debug
;;;373    				printf("SELF TEST finish\r\n\r\n");	
;;;374    				#endif
;;;375    			
;;;376    				break;	
;;;377    
;;;378    
;;;379    			case '7':
;;;380    
;;;381    				#if (_debug_log_UART_ == 1)	//debug
;;;382    				printf("perform SpiFlash_ChipErase\r\n");
;;;383    				#endif
;;;384    				
;;;385    			    /* Erase SPI flash */
;;;386    			    SpiFlash_ChipErase();
;;;387    
;;;388    			    /* Wait ready */
;;;389    			    SpiFlash_WaitReady();
;;;390    
;;;391    				#if (_debug_log_UART_ == 1)	//debug
;;;392    				printf("erase finish\r\n\r\n");
;;;393    				#endif
;;;394    
;;;395    				for ( page_cnt = 0 ; page_cnt < TEST_NUMBER ; page_cnt++)
;;;396    				{
;;;397    					#if (_debug_log_UART_ == 1)	//debug
;;;398    					printf("\r\nPDMA SELF TEST ... (idx : %2d)\r\n" , page_cnt);
;;;399    					#endif
;;;400    
;;;401    					//reset RxBuffer
;;;402    				    reset_buffer(RxBuffer,SPI_FLASH_PAGE_BYTE);
;;;403    
;;;404    					//reset TxBuffer
;;;405    					reset_buffer(TxBuffer,SPI_FLASH_PAGE_BYTE);
;;;406    
;;;407    					//fill in data
;;;408    				    for ( i = 0; i < SPI_FLASH_PAGE_BYTE; i++)
;;;409    				    {
;;;410    				        TxBuffer[i] = 0x00 + i + cnt;
;;;411    				    }
;;;412    
;;;413    //					printf("\r\nTxBuffer : \r\n");
;;;414    //					dump_buffer_hex(TxBuffer,SPI_FLASH_PAGE_BYTE);				
;;;415    					cnt++;
;;;416    					
;;;417    					SpiFlash_PageWrite(page_cnt,TxBuffer,SPI_FLASH_PAGE_BYTE,ENABLE);
;;;418    					SpiFlash_PageRead(page_cnt,RxBuffer,SPI_FLASH_PAGE_BYTE,ENABLE);
;;;419    
;;;420    //					printf("\r\nRxBuffer\r\n");
;;;421    //					dump_buffer_hex(RxBuffer,SPI_FLASH_PAGE_BYTE);		
;;;422    
;;;423    					compare_buffer(TxBuffer,RxBuffer,SPI_FLASH_PAGE_BYTE);
;;;424    				}
;;;425    
;;;426    				#if (_debug_log_UART_ == 1)	//debug
;;;427    				printf("PDMA SELF TEST finish\r\n\r\n");	
;;;428    				#endif
;;;429    
;;;430    				break;
;;;431    
;;;432    			case '8':			
;;;433    				i = SpiFlash_ReadMidDid();
;;;434    				#if (_debug_log_UART_ == 1)	//debug
;;;435    				printf("SpiFlash_ReadMidDid : 0x%2X\r\n\n" , i);
;;;436    				#endif
;;;437    				
;;;438    				break;
;;;439    
;;;440    			case '9':			
;;;441    //				SpiLED_TX_PDMA(SPI_LED0,TxBuffer,SPI_FLASH_PAGE_BYTE);
;;;442    
;;;443    				#if (_debug_log_UART_ == 1)	//debug
;;;444    				printf("perform SpiFlash_ChipErase\r\n");
;;;445    				#endif
;;;446    				
;;;447    			    /* Erase SPI flash */
;;;448    			    SpiFlash_ChipErase();
;;;449    
;;;450    			    /* Wait ready */
;;;451    			    SpiFlash_WaitReady();
;;;452    
;;;453    				#if (_debug_log_UART_ == 1)	//debug
;;;454    				printf("erase finish\r\n\r\n");
;;;455    				#endif
;;;456    
;;;457    				for ( sector_cnt = 0 ; sector_cnt < TEST_NUMBER ; sector_cnt++)
;;;458    				{
;;;459    					#if (_debug_log_UART_ == 1)	//debug
;;;460    					printf("\r\nPDMA SELF TEST (4K) ... (idx : %2d)\r\n" , sector_cnt);
;;;461    					#endif
;;;462    					
;;;463    					//reset RxBuffer
;;;464    				    reset_buffer(Rx4KBuffer,SPI_FLASH_SECTOR_SIZE);
;;;465    
;;;466    					//reset TxBuffer
;;;467    					reset_buffer(Tx4KBuffer,SPI_FLASH_SECTOR_SIZE);
;;;468    
;;;469    					//fill in data
;;;470    				    for ( i = 0; i < SPI_FLASH_SECTOR_SIZE ; i++)
;;;471    				    {
;;;472    				        Tx4KBuffer[i] = (uint8_t) (0x00 + i + cnt);
;;;473    				    }
;;;474    
;;;475    //					printf("\r\nTxBuffer : \r\n");
;;;476    //					dump_buffer_hex(Tx4KBuffer,SPI_FLASH_SECTOR_SIZE);				
;;;477    					cnt++;
;;;478    					
;;;479    					SpiFlash_SectorWrite(sector_cnt,Tx4KBuffer,SPI_FLASH_SECTOR_SIZE,ENABLE);
;;;480    					SpiFlash_SectorRead(sector_cnt,Rx4KBuffer,SPI_FLASH_SECTOR_SIZE,ENABLE);
;;;481    
;;;482    //					copy_buffer(Rx4KBuffer,buffer,SPI_FLASH_SECTOR_SIZE);
;;;483    
;;;484    //					printf("\r\nRxBuffer\r\n");
;;;485    //					dump_buffer_hex(Rx4KBuffer,SPI_FLASH_SECTOR_SIZE);		
;;;486    
;;;487    					compare_buffer(Tx4KBuffer,Rx4KBuffer,SPI_FLASH_SECTOR_SIZE);
;;;488    				}
;;;489    
;;;490    				#if (_debug_log_UART_ == 1)	//debug
;;;491    				printf("PDMA SELF TEST finish\r\n\r\n");	
;;;492    				#endif
;;;493    							
;;;494    				break;
;;;495    			
;;;496    			case 'X':
;;;497    			case 'x':
;;;498    			case 'Z':
;;;499    			case 'z':
;;;500    				NVIC_SystemReset();
;;;501    			
;;;502    				break;		
;;;503    			
;;;504    		}
;;;505    	}
;;;506    }
0000fe  e8bd87f0          POP      {r4-r10,pc}
000102  1c48              ADDS     r0,r1,#1              ;267
000104  7030              STRB     r0,[r6,#0]            ;267
000106  a0d5              ADR      r0,|L8.1116|
000108  e094              B        |L8.564|
                  |L8.266|
00010a  e08f              B        |L8.556|
00010c  a0de              ADR      r0,|L8.1160|
00010e  f7fffffe          BL       __2printf
000112  2301              MOVS     r3,#1                 ;283
000114  4642              MOV      r2,r8                 ;283
000116  496d              LDR      r1,|L8.716|
000118  7830              LDRB     r0,[r6,#0]            ;283  ; SPI_FLASH_page_counter
00011a  f7fffffe          BL       SpiFlash_SectorWrite
00011e  a0e0              ADR      r0,|L8.1184|
000120  e0c4              B        |L8.684|
000122  a0e5              ADR      r0,|L8.1208|
000124  f7fffffe          BL       __2printf
000128  4644              MOV      r4,r8                 ;312
00012a  4641              MOV      r1,r8                 ;312
00012c  48e8              LDR      r0,|L8.1232|
00012e  f7fffffe          BL       reset_buffer
000132  2301              MOVS     r3,#1                 ;315
000134  4622              MOV      r2,r4                 ;315
000136  49e6              LDR      r1,|L8.1232|
000138  7830              LDRB     r0,[r6,#0]            ;315  ; SPI_FLASH_page_counter
00013a  f7fffffe          BL       SpiFlash_SectorRead
00013e  4621              MOV      r1,r4                 ;318
000140  48e3              LDR      r0,|L8.1232|
000142  f7fffffe          BL       dump_buffer_hex
000146  e000              B        |L8.330|
                  |L8.328|
000148  e078              B        |L8.572|
                  |L8.330|
00014a  a0e2              ADR      r0,|L8.1236|
00014c  e0ae              B        |L8.684|
00014e  a0a8              ADR      r0,|L8.1008|
000150  f7fffffe          BL       __2printf
000154  f7fffffe          BL       SpiFlash_ChipErase
000158  f7fffffe          BL       SpiFlash_WaitReady
00015c  a0ac              ADR      r0,|L8.1040|
00015e  f7fffffe          BL       __2printf
000162  464f              MOV      r7,r9                 ;348
                  |L8.356|
000164  4629              MOV      r1,r5                 ;344
000166  a0e1              ADR      r0,|L8.1260|
000168  f7fffffe          BL       __2printf
00016c  4639              MOV      r1,r7                 ;348
00016e  48e7              LDR      r0,|L8.1292|
000170  f7fffffe          BL       reset_buffer
000174  4639              MOV      r1,r7                 ;351
000176  4857              LDR      r0,|L8.724|
000178  f7fffffe          BL       reset_buffer
00017c  7871              LDRB     r1,[r6,#1]            ;227
00017e  2000              MOVS     r0,#0                 ;354
                  |L8.384|
000180  1842              ADDS     r2,r0,r1              ;356
000182  5422              STRB     r2,[r4,r0]            ;356
000184  1c40              ADDS     r0,r0,#1              ;356
000186  b280              UXTH     r0,r0                 ;354
000188  28ff              CMP      r0,#0xff              ;354
00018a  d9f9              BLS      |L8.384|
00018c  1c49              ADDS     r1,r1,#1              ;354
00018e  7071              STRB     r1,[r6,#1]            ;361
000190  2300              MOVS     r3,#0                 ;363
000192  463a              MOV      r2,r7                 ;363
000194  494f              LDR      r1,|L8.724|
000196  4628              MOV      r0,r5                 ;363
000198  f7fffffe          BL       SpiFlash_PageWrite
00019c  2300              MOVS     r3,#0                 ;364
00019e  463a              MOV      r2,r7                 ;364
0001a0  49da              LDR      r1,|L8.1292|
0001a2  4628              MOV      r0,r5                 ;364
0001a4  f7fffffe          BL       SpiFlash_PageRead
0001a8  463a              MOV      r2,r7                 ;369
0001aa  49d8              LDR      r1,|L8.1292|
0001ac  4849              LDR      r0,|L8.724|
0001ae  f7fffffe          BL       compare_buffer
0001b2  1c6d              ADDS     r5,r5,#1              ;369
0001b4  b2ad              UXTH     r5,r5                 ;341
0001b6  2d10              CMP      r5,#0x10              ;341
0001b8  d3d4              BCC      |L8.356|
0001ba  a0d5              ADR      r0,|L8.1296|
0001bc  e076              B        |L8.684|
0001be  a08c              ADR      r0,|L8.1008|
0001c0  f7fffffe          BL       __2printf
0001c4  f7fffffe          BL       SpiFlash_ChipErase
0001c8  f7fffffe          BL       SpiFlash_WaitReady
0001cc  a090              ADR      r0,|L8.1040|
0001ce  f7fffffe          BL       __2printf
0001d2  464f              MOV      r7,r9                 ;348
                  |L8.468|
0001d4  4629              MOV      r1,r5                 ;398
0001d6  a0d4              ADR      r0,|L8.1320|
0001d8  f7fffffe          BL       __2printf
0001dc  4639              MOV      r1,r7                 ;402
0001de  48cb              LDR      r0,|L8.1292|
0001e0  f7fffffe          BL       reset_buffer
0001e4  4639              MOV      r1,r7                 ;405
0001e6  483b              LDR      r0,|L8.724|
0001e8  f7fffffe          BL       reset_buffer
0001ec  7871              LDRB     r1,[r6,#1]            ;227
0001ee  2000              MOVS     r0,#0                 ;408
                  |L8.496|
0001f0  1842              ADDS     r2,r0,r1              ;410
0001f2  5422              STRB     r2,[r4,r0]            ;410
0001f4  1c40              ADDS     r0,r0,#1              ;410
0001f6  b280              UXTH     r0,r0                 ;408
0001f8  28ff              CMP      r0,#0xff              ;408
0001fa  d9f9              BLS      |L8.496|
0001fc  1c49              ADDS     r1,r1,#1              ;408
0001fe  7071              STRB     r1,[r6,#1]            ;415
000200  2301              MOVS     r3,#1                 ;417
000202  463a              MOV      r2,r7                 ;417
000204  4933              LDR      r1,|L8.724|
000206  4628              MOV      r0,r5                 ;417
000208  f7fffffe          BL       SpiFlash_PageWrite
00020c  2301              MOVS     r3,#1                 ;418
00020e  463a              MOV      r2,r7                 ;418
000210  49be              LDR      r1,|L8.1292|
000212  4628              MOV      r0,r5                 ;418
000214  f7fffffe          BL       SpiFlash_PageRead
000218  463a              MOV      r2,r7                 ;423
00021a  49bc              LDR      r1,|L8.1292|
00021c  482d              LDR      r0,|L8.724|
00021e  f7fffffe          BL       compare_buffer
000222  1c6d              ADDS     r5,r5,#1              ;423
000224  b2ad              UXTH     r5,r5                 ;395
000226  2d10              CMP      r5,#0x10              ;395
000228  d3d4              BCC      |L8.468|
00022a  e03e              B        |L8.682|
                  |L8.556|
00022c  f7fffffe          BL       SpiFlash_ReadMidDid
000230  4601              MOV      r1,r0                 ;433
000232  a0c6              ADR      r0,|L8.1356|
                  |L8.564|
000234  e8bd47f0          POP      {r4-r10,lr}           ;435
000238  f7ffbffe          B.W      __2printf
                  |L8.572|
00023c  a06c              ADR      r0,|L8.1008|
00023e  f7fffffe          BL       __2printf
000242  f7fffffe          BL       SpiFlash_ChipErase
000246  f7fffffe          BL       SpiFlash_WaitReady
00024a  a071              ADR      r0,|L8.1040|
00024c  f7fffffe          BL       __2printf
000250  4657              MOV      r7,r10                ;247
000252  4645              MOV      r5,r8                 ;247
                  |L8.596|
000254  4621              MOV      r1,r4                 ;460
000256  a0c5              ADR      r0,|L8.1388|
000258  f7fffffe          BL       __2printf
00025c  4629              MOV      r1,r5                 ;464
00025e  489c              LDR      r0,|L8.1232|
000260  f7fffffe          BL       reset_buffer
000264  4629              MOV      r1,r5                 ;467
000266  4819              LDR      r0,|L8.716|
000268  f7fffffe          BL       reset_buffer
00026c  7871              LDRB     r1,[r6,#1]            ;227
00026e  2000              MOVS     r0,#0                 ;470
                  |L8.624|
000270  1842              ADDS     r2,r0,r1              ;472
000272  543a              STRB     r2,[r7,r0]            ;472
000274  1c40              ADDS     r0,r0,#1              ;472
000276  b280              UXTH     r0,r0                 ;470
000278  42a8              CMP      r0,r5                 ;470
00027a  d3f9              BCC      |L8.624|
00027c  1c49              ADDS     r1,r1,#1              ;470
00027e  7071              STRB     r1,[r6,#1]            ;477
000280  2301              MOVS     r3,#1                 ;479
000282  462a              MOV      r2,r5                 ;479
000284  4911              LDR      r1,|L8.716|
000286  4620              MOV      r0,r4                 ;479
000288  f7fffffe          BL       SpiFlash_SectorWrite
00028c  2301              MOVS     r3,#1                 ;480
00028e  462a              MOV      r2,r5                 ;480
000290  498f              LDR      r1,|L8.1232|
000292  4620              MOV      r0,r4                 ;480
000294  f7fffffe          BL       SpiFlash_SectorRead
000298  462a              MOV      r2,r5                 ;487
00029a  498d              LDR      r1,|L8.1232|
00029c  480b              LDR      r0,|L8.716|
00029e  f7fffffe          BL       compare_buffer
0002a2  1c64              ADDS     r4,r4,#1              ;487
0002a4  b2a4              UXTH     r4,r4                 ;457
0002a6  2c10              CMP      r4,#0x10              ;457
0002a8  d3d4              BCC      |L8.596|
                  |L8.682|
0002aa  a0ba              ADR      r0,|L8.1428|
                  |L8.684|
0002ac  e8bd47f0          POP      {r4-r10,lr}           ;491
0002b0  f7ffbffe          B.W      __2printf
;;;507    
                          ENDP

                  |L8.692|
                          DCD      0x40070000
                  |L8.696|
0002b8  696e7661          DCB      "invalid command\r\n",0
0002bc  6c696420
0002c0  636f6d6d
0002c4  616e640d
0002c8  0a00    
0002ca  00                DCB      0
0002cb  00                DCB      0
                  |L8.716|
                          DCD      ||.bss||+0x200
                  |L8.720|
                          DCD      ||.data||
                  |L8.724|
                          DCD      ||.bss||
                  |L8.728|
                          DCD      0xe000ed0c
                  |L8.732|
                          DCD      0x05fa0004
                  |L8.736|
0002e0  0d0a3d3d          DCB      "\r\n==========================\r\n",0
0002e4  3d3d3d3d
0002e8  3d3d3d3d
0002ec  3d3d3d3d
0002f0  3d3d3d3d
0002f4  3d3d3d3d
0002f8  3d3d3d3d
0002fc  0d0a00  
0002ff  00                DCB      0
                  |L8.768|
000300  313a2063          DCB      "1: chip erase\r\n",0
000304  68697020
000308  65726173
00030c  650d0a00
                  |L8.784|
000310  323a2066          DCB      "2: fill in TX data\r\n",0
000314  696c6c20
000318  696e2054
00031c  58206461
000320  74610d0a
000324  00      
000325  00                DCB      0
000326  00                DCB      0
000327  00                DCB      0
                  |L8.808|
000328  333a2070          DCB      "3: page counter\r\n",0
00032c  61676520
000330  636f756e
000334  7465720d
000338  0a00    
00033a  00                DCB      0
00033b  00                DCB      0
                  |L8.828|
00033c  343a2050          DCB      "4: Page write\r\n",0
000340  61676520
000344  77726974
000348  650d0a00
                  |L8.844|
00034c  353a2050          DCB      "5: Page read\r\n",0
000350  61676520
000354  72656164
000358  0d0a00  
00035b  00                DCB      0
                  |L8.860|
00035c  363a2073          DCB      "6: self test , write , read , compare\r\n",0
000360  656c6620
000364  74657374
000368  202c2077
00036c  72697465
000370  202c2072
000374  65616420
000378  2c20636f
00037c  6d706172
000380  650d0a00
                  |L8.900|
000384  373a2073          DCB      "7: self test , write , read , compare  , with PDMA\r\n",0
000388  656c6620
00038c  74657374
000390  202c2077
000394  72697465
000398  202c2072
00039c  65616420
0003a0  2c20636f
0003a4  6d706172
0003a8  6520202c
0003ac  20776974
0003b0  68205044
0003b4  4d410d0a
0003b8  00      
0003b9  00                DCB      0
0003ba  00                DCB      0
0003bb  00                DCB      0
                  |L8.956|
0003bc  383a2072          DCB      "8: read ID (0x90)\r\n",0
0003c0  65616420
0003c4  49442028
0003c8  30783930
0003cc  290d0a00
                  |L8.976|
0003d0  3d3d3d3d          DCB      "==========================\r\n\r\n",0
0003d4  3d3d3d3d
0003d8  3d3d3d3d
0003dc  3d3d3d3d
0003e0  3d3d3d3d
0003e4  3d3d3d3d
0003e8  3d3d0d0a
0003ec  0d0a00  
0003ef  00                DCB      0
                  |L8.1008|
0003f0  70657266          DCB      "perform SpiFlash_ChipErase\r\n",0
0003f4  6f726d20
0003f8  53706946
0003fc  6c617368
000400  5f436869
000404  70457261
000408  73650d0a
00040c  00      
00040d  00                DCB      0
00040e  00                DCB      0
00040f  00                DCB      0
                  |L8.1040|
000410  65726173          DCB      "erase finish\r\n\r\n",0
000414  65206669
000418  6e697368
00041c  0d0a0d0a
000420  00      
000421  00                DCB      0
000422  00                DCB      0
000423  00                DCB      0
                  |L8.1060|
000424  696e6372          DCB      "increase test data start from 0x%2X\r\n",0
000428  65617365
00042c  20746573
000430  74206461
000434  74612073
000438  74617274
00043c  2066726f
000440  6d203078
000444  2532580d
000448  0a00    
00044a  00                DCB      0
00044b  00                DCB      0
                  |L8.1100|
00044c  5478344b          DCB      "Tx4KBuffer : \r\n",0
000450  42756666
000454  6572203a
000458  200d0a00
                  |L8.1116|
00045c  5350495f          DCB      "SPI_FLASH_page_counter current : 0x%2X\r\n\r\n",0
000460  464c4153
000464  485f7061
000468  67655f63
00046c  6f756e74
000470  65722063
000474  75727265
000478  6e74203a
00047c  20307825
000480  32580d0a
000484  0d0a00  
000487  00                DCB      0
                  |L8.1160|
000488  70726f67          DCB      "programming...(%d)\r\n",0
00048c  72616d6d
000490  696e672e
000494  2e2e2825
000498  64290d0a
00049c  00      
00049d  00                DCB      0
00049e  00                DCB      0
00049f  00                DCB      0
                  |L8.1184|
0004a0  70726f67          DCB      "programming finish\r\n\r\n",0
0004a4  72616d6d
0004a8  696e6720
0004ac  66696e69
0004b0  73680d0a
0004b4  0d0a00  
0004b7  00                DCB      0
                  |L8.1208|
0004b8  72656164          DCB      "read page ...(%2d)\r\n",0
0004bc  20706167
0004c0  65202e2e
0004c4  2e282532
0004c8  64290d0a
0004cc  00      
0004cd  00                DCB      0
0004ce  00                DCB      0
0004cf  00                DCB      0
                  |L8.1232|
                          DCD      ||.bss||+0x1200
                  |L8.1236|
0004d4  72656164          DCB      "read page finish\r\n\r\n",0
0004d8  20706167
0004dc  65206669
0004e0  6e697368
0004e4  0d0a0d0a
0004e8  00      
0004e9  00                DCB      0
0004ea  00                DCB      0
0004eb  00                DCB      0
                  |L8.1260|
0004ec  0d0a5345          DCB      "\r\nSELF TEST ... (idx : %2d)\r\n",0
0004f0  4c462054
0004f4  45535420
0004f8  2e2e2e20
0004fc  28696478
000500  203a2025
000504  3264290d
000508  0a00    
00050a  00                DCB      0
00050b  00                DCB      0
                  |L8.1292|
                          DCD      ||.bss||+0x100
                  |L8.1296|
000510  53454c46          DCB      "SELF TEST finish\r\n\r\n",0
000514  20544553
000518  54206669
00051c  6e697368
000520  0d0a0d0a
000524  00      
000525  00                DCB      0
000526  00                DCB      0
000527  00                DCB      0
                  |L8.1320|
000528  0d0a5044          DCB      "\r\nPDMA SELF TEST ... (idx : %2d)\r\n",0
00052c  4d412053
000530  454c4620
000534  54455354
000538  202e2e2e
00053c  20286964
000540  78203a20
000544  25326429
000548  0d0a00  
00054b  00                DCB      0
                  |L8.1356|
00054c  53706946          DCB      "SpiFlash_ReadMidDid : 0x%2X\r\n\n",0
000550  6c617368
000554  5f526561
000558  644d6964
00055c  44696420
000560  3a203078
000564  2532580d
000568  0a0a00  
00056b  00                DCB      0
                  |L8.1388|
00056c  0d0a5044          DCB      "\r\nPDMA SELF TEST (4K) ... (idx : %2d)\r\n",0
000570  4d412053
000574  454c4620
000578  54455354
00057c  2028344b
000580  29202e2e
000584  2e202869
000588  6478203a
00058c  20253264
000590  290d0a00
                  |L8.1428|
000594  50444d41          DCB      "PDMA SELF TEST finish\r\n\r\n",0
000598  2053454c
00059c  46205445
0005a0  53542066
0005a4  696e6973
0005a8  680d0a0d
0005ac  0a00    
0005ae  00                DCB      0
0005af  00                DCB      0

                          AREA ||i.compare_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  compare_buffer PROC
;;;42     /*_____ F U N C T I O N S ______------______________________________________*/
;;;43     void compare_buffer(uint8_t *src, uint8_t *des, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;44     {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  4680              MOV      r8,r0
;;;45         uint16_t i = 0;	
00000a  2400              MOVS     r4,#0
;;;46     	
;;;47         for (i = 0; i < nBytes; i++)
;;;48         {
;;;49             if (src[i] != des[i])
;;;50             {
;;;51     			#if (_debug_log_UART_ == 1)	//debug
;;;52                 printf("error idx : %4d : 0x%2X , 0x%2X\r\n", i , src[i],des[i]);
;;;53     			#endif
;;;54     			set_flag(flag_compare_error , ENABLE);
00000c  4d0f              LDR      r5,|L9.76|
00000e  e00e              B        |L9.46|
                  |L9.16|
000010  f8182004          LDRB     r2,[r8,r4]            ;49
000014  5d3b              LDRB     r3,[r7,r4]            ;49
000016  429a              CMP      r2,r3                 ;49
000018  d007              BEQ      |L9.42|
00001a  4621              MOV      r1,r4                 ;52
00001c  a00c              ADR      r0,|L9.80|
00001e  f7fffffe          BL       __2printf
000022  6868              LDR      r0,[r5,#4]  ; BitFlag
000024  f0400002          ORR      r0,r0,#2
000028  6068              STR      r0,[r5,#4]  ; BitFlag
                  |L9.42|
00002a  1c64              ADDS     r4,r4,#1
00002c  b2a4              UXTH     r4,r4                 ;47
                  |L9.46|
00002e  42b4              CMP      r4,r6                 ;47
000030  dbee              BLT      |L9.16|
;;;55             }
;;;56         }
;;;57     
;;;58     	if (!is_flag_set(flag_compare_error))
000032  6868              LDR      r0,[r5,#4]  ; BitFlag
000034  0780              LSLS     r0,r0,#30
000036  d407              BMI      |L9.72|
;;;59     	{
;;;60     		#if (_debug_log_UART_ == 1)	//debug
;;;61         	printf("%s finish \r\n" , __FUNCTION__);	
000038  490e              LDR      r1,|L9.116|
00003a  a00f              ADR      r0,|L9.120|
00003c  f7fffffe          BL       __2printf
;;;62     		#endif
;;;63     		set_flag(flag_compare_error , DISABLE);
000040  6868              LDR      r0,[r5,#4]  ; BitFlag
000042  f0200002          BIC      r0,r0,#2
000046  6068              STR      r0,[r5,#4]  ; BitFlag
                  |L9.72|
;;;64     	}
;;;65     
;;;66     }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;67     
                          ENDP

                  |L9.76|
                          DCD      ||.data||
                  |L9.80|
000050  6572726f          DCB      "error idx : %4d : 0x%2X , 0x%2X\r\n",0
000054  72206964
000058  78203a20
00005c  25346420
000060  3a203078
000064  25325820
000068  2c203078
00006c  2532580d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0
                  |L9.116|
                          DCD      ||.constdata||
                  |L9.120|
000078  25732066          DCB      "%s finish \r\n",0
00007c  696e6973
000080  68200d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.copy_buffer||, CODE, READONLY, ALIGN=1

                  copy_buffer PROC
;;;121    
;;;122    void copy_buffer(void *dest, void *src, unsigned int size)
000000  b510              PUSH     {r4,lr}
;;;123    {
;;;124        uint8_t *pu8Src, *pu8Dest;
;;;125        unsigned int i;
;;;126        
;;;127        pu8Dest = (uint8_t *)dest;
;;;128        pu8Src  = (uint8_t *)src;
;;;129    
;;;130    
;;;131    	#if 0
;;;132    	  while (size--)
;;;133    	    *pu8Dest++ = *pu8Src++;
;;;134    	#else
;;;135        for (i = 0; i < size; i++)
000002  2300              MOVS     r3,#0
000004  e002              B        |L10.12|
                  |L10.6|
;;;136            pu8Dest[i] = pu8Src[i];
000006  5ccc              LDRB     r4,[r1,r3]
000008  54c4              STRB     r4,[r0,r3]
00000a  1c5b              ADDS     r3,r3,#1
                  |L10.12|
00000c  4293              CMP      r3,r2                 ;135
00000e  d3fa              BCC      |L10.6|
;;;137    	#endif
;;;138    }
000010  bd10              POP      {r4,pc}
;;;139    
                          ENDP


                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;80     
;;;81     void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;82     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;83         uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;84         
;;;85         printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L11.56|
00000a  f7fffffe          BL       __2printf
;;;86         for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L11.42|
                  |L11.16|
;;;87         {
;;;88             printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L11.76|
000014  f7fffffe          BL       __2printf
;;;89             if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L11.38|
;;;90             {
;;;91                 printf("\r\n");
000020  a00c              ADR      r0,|L11.84|
000022  f7fffffe          BL       __2printf
                  |L11.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;86
                  |L11.42|
00002a  42ac              CMP      r4,r5                 ;86
00002c  dbf0              BLT      |L11.16|
;;;92             }            
;;;93         }
;;;94         printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L11.88|
000034  f7ffbffe          B.W      __2printf
;;;95     }
;;;96     
                          ENDP

                  |L11.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L11.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L11.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L11.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.dump_buffer_hex||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dump_buffer_hex PROC
;;;96     
;;;97     void  dump_buffer_hex(uint8_t *pucBuff, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;98     {
000004  460e              MOV      r6,r1
000006  4607              MOV      r7,r0
;;;99         int     nIdx, i;
;;;100    
;;;101        nIdx = 0;
000008  2500              MOVS     r5,#0
00000a  e025              B        |L12.88|
                  |L12.12|
;;;102        while (nBytes > 0)
;;;103        {
;;;104            printf("0x%04X  ", nIdx);
00000c  4629              MOV      r1,r5
00000e  a016              ADR      r0,|L12.104|
000010  f7fffffe          BL       __2printf
;;;105            for (i = 0; i < 16; i++)
000014  2400              MOVS     r4,#0
                  |L12.22|
;;;106                printf("%02X ", pucBuff[nIdx + i]);
000016  1928              ADDS     r0,r5,r4
000018  5c39              LDRB     r1,[r7,r0]
00001a  a016              ADR      r0,|L12.116|
00001c  f7fffffe          BL       __2printf
000020  1c64              ADDS     r4,r4,#1
000022  2c10              CMP      r4,#0x10              ;105
000024  dbf7              BLT      |L12.22|
;;;107            printf("  ");
000026  a015              ADR      r0,|L12.124|
000028  f7fffffe          BL       __2printf
;;;108            for (i = 0; i < 16; i++)
00002c  2400              MOVS     r4,#0
                  |L12.46|
;;;109            {
;;;110                if ((pucBuff[nIdx + i] >= 0x20) && (pucBuff[nIdx + i] < 127))
00002e  1928              ADDS     r0,r5,r4
000030  5c39              LDRB     r1,[r7,r0]
000032  f1a10020          SUB      r0,r1,#0x20
000036  285f              CMP      r0,#0x5f
000038  d203              BCS      |L12.66|
;;;111                    printf("%c", pucBuff[nIdx + i]);
00003a  a011              ADR      r0,|L12.128|
00003c  f7fffffe          BL       __2printf
000040  e002              B        |L12.72|
                  |L12.66|
;;;112                else
;;;113                    printf(".");
000042  a010              ADR      r0,|L12.132|
000044  f7fffffe          BL       __2printf
                  |L12.72|
000048  1c64              ADDS     r4,r4,#1
00004a  1e76              SUBS     r6,r6,#1
00004c  2c10              CMP      r4,#0x10              ;108
00004e  dbee              BLT      |L12.46|
;;;114                nBytes--;
;;;115            }
;;;116            nIdx += 16;
;;;117            printf("\n");
000050  a00d              ADR      r0,|L12.136|
000052  3510              ADDS     r5,r5,#0x10
000054  f7fffffe          BL       __2printf
                  |L12.88|
000058  2e00              CMP      r6,#0                 ;102
00005a  dcd7              BGT      |L12.12|
;;;118        }
;;;119        printf("\n");
00005c  e8bd41f0          POP      {r4-r8,lr}
000060  a009              ADR      r0,|L12.136|
000062  f7ffbffe          B.W      __2printf
;;;120    }
;;;121    
                          ENDP

000066  0000              DCW      0x0000
                  |L12.104|
000068  30782530          DCB      "0x%04X  ",0
00006c  34582020
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L12.116|
000074  25303258          DCB      "%02X ",0
000078  2000    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L12.124|
00007c  202000            DCB      "  ",0
00007f  00                DCB      0
                  |L12.128|
000080  256300            DCB      "%c",0
000083  00                DCB      0
                  |L12.132|
000084  2e00              DCB      ".",0
000086  00                DCB      0
000087  00                DCB      0
                  |L12.136|
000088  0a00              DCB      "\n",0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;714    
;;;715    int main()
000000  f7fffffe          BL       SYS_Init
;;;716    {	
;;;717        SYS_Init();
;;;718    
;;;719    	UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;720    	Custom_Init();	
000008  f7fffffe          BL       Custom_Init
;;;721    
;;;722    	TIMER1_Init();
00000c  f7fffffe          BL       TIMER1_Init
;;;723    
;;;724    //    NVIC_EnableIRQ(PDMA_IRQn);
;;;725    	SpiFlash_Init();
000010  f7fffffe          BL       SpiFlash_Init
                  |L13.20|
;;;726    	
;;;727        /* Got no where to go, just loop forever */
;;;728        while(1)
000014  e7fe              B        |L13.20|
;;;729        {
;;;730    
;;;731        }
;;;732    }
;;;733    
                          ENDP


                          AREA ||i.reset_buffer||, CODE, READONLY, ALIGN=1

                  reset_buffer PROC
;;;67     
;;;68     void reset_buffer(uint8_t *pucBuff, int nBytes)
000000  2200              MOVS     r2,#0
;;;69     {
;;;70     	#if 1
;;;71         uint16_t i = 0;	
000002  4613              MOV      r3,r2
000004  e002              B        |L14.12|
                  |L14.6|
;;;72         for ( i = 0; i < nBytes; i++)
;;;73         {
;;;74             pucBuff[i] = 0x00;
000006  5483              STRB     r3,[r0,r2]
000008  1c52              ADDS     r2,r2,#1
00000a  b292              UXTH     r2,r2                 ;72
                  |L14.12|
00000c  428a              CMP      r2,r1                 ;72
00000e  dbfa              BLT      |L14.6|
;;;75         }	
;;;76     	#else	//extra 20 bytes , with <string.h>
;;;77     	memset(pucBuff, 0, nBytes * (sizeof(pucBuff[0]) ));
;;;78     	#endif
;;;79     }
000010  4770              BX       lr
;;;80     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  TxBuffer
                          %        256
                  RxBuffer
                          %        256
                  Tx4KBuffer
                          %        4096
                  Rx4KBuffer
                          %        4096

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  636f6d70          DCB      0x63,0x6f,0x6d,0x70
000004  6172655f          DCB      0x61,0x72,0x65,0x5f
000008  62756666          DCB      0x62,0x75,0x66,0x66
00000c  657200            DCB      0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  SPI_FLASH_page_counter
000000  00                DCB      0x00
                  ||cnt||
000001  00                DCB      0x00
                  CNT_1000ms
000002  0000              DCW      0x0000
                  BitFlag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_TxBuffer____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_TxBuffer____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_TxBuffer____REVSH|
#line 402
|__asm___6_main_c_TxBuffer____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_TxBuffer____RRX|
#line 587
|__asm___6_main_c_TxBuffer____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
